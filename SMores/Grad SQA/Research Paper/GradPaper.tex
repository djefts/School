\documentclass[10pt, final, journal, letterpaper, twoside, twocolumn]{IEEEtran}
\usepackage[utf8]{inputenc}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage[numbers]{natbib}
\usepackage{layout}
\usepackage [english]{babel}
\usepackage [autostyle, english = american]{csquotes}
\MakeOuterQuote{"}
\usepackage{url}

\begin{document}

\title{Assuring Software Quality Through the Use of Fuzzy Testing}
\author{\IEEEauthorblockN{David Jefts} \\
	\IEEEauthorblockA{SE625, Software Quality Assurance}}
\IEEEspecialpapernotice{Embry-Riddle Aeronautical University}
%\thanks{\LaTeX}
\markboth{\LaTeX}{SE625}

\maketitle

%%%%%%
%I assume you will introduce the concept of Fuzzy testing, how it is used, where it is used, advantages disadvantages, etc. etc.   If this is correct, you are good to go.
%%%%%%

\begin{abstract}
	%%%%%%%%%%%%%% THIS IS NOT MY ABSTRACT %%%%%%%%%%%%%%
	\textbf{\textit{THIS IS NOT MY ABSTRACT}} Software engineering researchers solve problems of several different kinds. To do so, they produce  several different kinds of results, and they should develop appropriate evidence to validate these results. They often report their research in conference papers. I analyzed the abstracts of research papers submitted to ICSE 2002 in order to identify the types of research reported in the submitted and accepted papers, and I observed the program committee discussions about which papers to accept. This report presents the research paradigms of the papers, common concerns of the program committee, and statistics on success rates. This information should help researchers design better research projects and write papers that present their results to best advantage. 
	
	This paper makes the case for TaaS—automated software testing as a cloud-based service. We present three kinds of TaaS: a “programmer’s sidekick” enabling developers to thoroughly and promptly test their code with minimal upfront resource investment; a “home edition” on-demand testing service for consumers to verify the software they are about to install on their PC or mobile device; and a public “certification service,” akin to Underwriters Labs, that independently assesses the reliability, safety, and security of software.
	TaaS automatically tests software, without human involvement from the service user’s or provider’s side. This is unlike today’s “testing as a service” businesses, which employ humans to write tests. Our goal is to take recently proposed techniques for automated testing—even if usable only on toy programs—and make them practical by modifying them to harness the resources of compute clouds. Preliminary work suggests it is technically feasible to do so, and we find that TaaS is also compelling from a social and business point of view.
\end{abstract}

\begin{IEEEkeywords}
	Fuzzy Testing, Fuzz Testing, Fuzzing, Smart Fuzzing, Software Quality Assurance, Quality Assurance, Software Vulnerabilities, Software Reliability, Testing, Automated Testing, Error Detection, Software Errors, Debugging, Computer Bugs, Computer Security, Testing, Product Testing, System Testing
\end{IEEEkeywords}

\section{Introduction}
	%Introduction
	\IEEEPARstart{E}{nsuring} that software works properly before public (or private) release is important because software bugs, or in-code errors, can cost the developing company a lot of money. Software bugs cause program faults, and faults cause program failures. Maintenance and repair is 65-85\% of system cost \cite{slide-defect}. Naturally, the goal during software development is to limit these defects by testing the software before release. However, "software testing is a very labor intensive and costly task, [though] many software testing techniques to automate the process of software testing have been [designed and] reported in the literature" \cite{fuzzy-logic}. One such technique is Fuzzy Testing, also called Fuzzing.
	
	%Why I chose this topic
	Fuzzy testing is an important topic to study because it offers an automated way to test software that is mostly reliable. What is most interesting about it is that it incorporates many different fields from the software and computer fields: Software Development/Engineering is the main application of Fuzzy Testing, Software Quality Assurance is the entire goal of Fuzzy Testing, Artificial Intelligence and Machine Learning are being used to help optimize various fuzzy testing techniques, and Software Penetration and Security Testing also uses Fuzzy Testing to "verify security functionality" \cite{penetration}.
	
	%Goal of this paper
	This paper seeks to summarize much of the leading-edge research on fuzzy testing. It makes the case for a much more proliferated use of fuzzy testing in the software industry and promotes additional research for better ways to optimize fuzzy testing. "Automated software testing, available to anyone and everyone at low cost, can transform the current development paradigm into one that involves more-thorough yet less-time-consuming testing" \cite{automation}. By promoting fuzzy testing as a whole, along with further development of fuzzy testing, automated software testing can be made more reliable and easier to access.


\section{Software Testing}
	There are two main 'sectors', or approaches, to software testing: white-box testing and black-box testing \cite{boxes}. White Box Testing, also called Structural Testing \cite{slide-testing}, is the testing of a system \textit{with} knowledge of the internal systems software. Testers in this paradigm "have access to the source code and are aware of the system architecture" \cite{boxes}. Generally, White Box testers analyze the source code of the software and develop test cases and identify specific code paths to achieve the most raw code coverage. They develop test cases with respect to executed statements, branches, paths, and so forth. "After initial testing, programmers frequently face the problem of finding additional test data to evaluate program elements not yet covered" \cite{assertion}. Determining the test data required to evaluate 100\% of the software is often very labor-intensive and expensive. Test generators in the White Box testing paradigm work to find program input(s) on which a selected portion of the software is executed. According to \cite{assertion}, there are currently three types of automatic generators for this: \textit{random} test generators, \textit{path-oriented} generators, and \textit{goal-oriented} generators. White Box testing generally finds more bugs and defects as compared to Black Box Testing. However it requires more time and money than Black Box Testing, since it requires a direct analysis of the source code and tests must cover 100\% of the code.
	
	Black Box Testing, also called Functional Testing \cite{slide-testing}, is the testing of a system with no knowledge or direct access of the internal systems in the software. Testers in this paradigm "do not have access to the source code and are oblivious of the system architecture" \cite{boxes}, and select test data "based on the functional specification of the program (e.g., equivalence class partitioning, boundary-value analysis)" \cite{assertion}. Black Box testers just test the software through the provided user interface and analyzing inputs and outputs for correctness. Test generators working off of the Black Box paradigm create test cases and test data by "using a set of rules and procedures; the most popular methods include equivalence class partitioning, boundary value analysis, [and] cause-effect graphing" \cite{assertion}. "By their nature Black Box testing methods might not lead to the execution of all parts of the code. Therefore, this method may not uncover all faults in the program" \cite{fuzzy-logic}.
	
	Reportedly, a largely effective software testing technique is called \textit{Assertion-Based} \cite{assertion}. It involves finding program inputs in which various assertions are violated. When these assertions are violated then there is a fault in the program \cite{assertion}. Some languages support this by default, for example Java and Perl. According to \cite{fuzzy-logic} it is fairly easy to generate assertion tests; "creating boundary checks, division by zero, null pointers, and variable overflow/underflow" \cite{fuzzy-logic}. The problem with this method of software testing is that the implementation of large amounts of assertions can be costly and is often impractical for industrial-sized software. 


\section{Fuzzy Testing}
	%What is fuzzy testing?
	
	%Fuzzy testing techniques
	SEE \cite{break-software}
	
	%Examples of use of fuzzy testing in industry
	
		%Explain the context of these comparisons
		
	%Analyze potential applications and best-case uses for fuzzy testing
	

\section{Fuzzy Testing as Compared To Other Software Testing Techniques}
	%Advantages and disadvantages of fuzzy testing
	
	%Fuzzy Testing vs Other Fuzzy Testing techniques

\section{Conclusion}
	%Is fuzzy testing better or worse than other methods of testing and for which cases is it better?

\pagebreak
	
%Appendices
\appendices
	\section{}
		Stuffity stuff stuff stuff
	\section{}
		More stuffy things
	
%Bibliography
\newpage
\nocite{*}
\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,bibliography}

\end{document}
